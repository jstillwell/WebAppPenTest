using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WebAppPenTest.Spider;
using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Models;

namespace WebAppPenTest.Proxy {
    /// <summary>
    /// This will intercept the HTTP traffic.
    /// </summary>
    public class Listener : IDisposable {
        public Queue<string> Packets = new Queue<string>(); //will contain all captured packets to be processed.
        public bool cancelled = false;
        public bool IsProxyOn = false;
        private ProxyServer Proxy = new ProxyServer();
        private ExplicitProxyEndPoint explicitEndPoint;
        private TransparentProxyEndPoint transparentEndPoint;

        public Listener() {
            SetupProxy();
        }
        /// <summary>
        /// Sets up the necessary settings for using the Titanium proxy.
        /// </summary>
        private void SetupProxy() {
            //Exclude Https addresses you don't want to proxy
            //Usefull for clients that use certificate pinning
            //for example dropbox.com
            explicitEndPoint = new ExplicitProxyEndPoint(IPAddress.Any, 8000, true) {
                // ExcludedHttpsHostNameRegex = new List<string>() { "google.com", "dropbox.com" }
            };

            //Transparent endpoint is usefull for reverse proxying (client is not aware of the existance of proxy)
            //A transparent endpoint usually requires a network router port forwarding HTTP(S) packets to this endpoint
            //Currently do not support Server Name Indication (It is not currently supported by SslStream class)
            //That means that the transparent endpoint will always provide the same Generic Certificate to all HTTPS requests
            //In this example only google.com will work for HTTPS requests
            //Other sites will receive a certificate mismatch warning on browser
            transparentEndPoint = new TransparentProxyEndPoint(IPAddress.Any, 8001, true) {
                //GenericCertificateName = "google.com"
            };

            //ProxyServer.UpStreamHttpProxy = new ExternalProxy() { HostName = "localhost", Port = 8888 };
            //ProxyServer.UpStreamHttpsProxy = new ExternalProxy() { HostName = "localhost", Port = 8888 };

            //foreach (var endPoint in Proxy.ProxyEndPoints)
            //    Console.WriteLine("Listening on '{0}' endpoint at Ip {1} and port: {2} ",
            //        endPoint.GetType().Name, endPoint.IpAddress, endPoint.Port);
        }
        /// <summary>
        /// Starts the proxy server and sets up events for capture.
        /// </summary>
        public void StartListener() {
            if (!IsProxyOn) {
                Proxy.Start();
                IsProxyOn = true;

                //An explicit endpoint is where the client knows about the existance of a proxy
                //So client sends request in a proxy friendly manner
                Proxy.AddEndPoint(explicitEndPoint);

                Proxy.AddEndPoint(transparentEndPoint);
                //Only explicit proxies can be set as system proxy!
                Proxy.SetAsSystemHttpProxy(explicitEndPoint);
                Proxy.SetAsSystemHttpsProxy(explicitEndPoint);

                // listen to client request & server response events
                Proxy.BeforeRequest += OnRequest;
                Proxy.BeforeResponse += OnResponse;
                Proxy.ServerCertificateValidationCallback += OnCertificateValidation;
                Proxy.ClientCertificateSelectionCallback += OnCertificateSelection;
            }
        }
        /// <summary>
        /// Stops the listener and removes events for capture.
        /// </summary>
        public void StopListener() {
            //Unsubscribe & Quit
            Proxy.BeforeRequest -= OnRequest;
            Proxy.BeforeResponse -= OnResponse;
            //Proxy.ServerCertificateValidationCallback -= OnCertificateValidation;
            //Proxy.ClientCertificateSelectionCallback -= OnCertificateSelection;

            if (IsProxyOn) {
                Proxy.Stop();
                IsProxyOn = false;
            }
        }
        private Task OnCertificateSelection(object arg1, CertificateSelectionEventArgs arg2) {
            return Task.FromResult(0);
        }
        private Task OnCertificateValidation(object sender, CertificateValidationEventArgs e) {
            //set IsValid to true/false based on Certificate Errors
            if (e.SslPolicyErrors == System.Net.Security.SslPolicyErrors.None)
                e.IsValid = true;

            return Task.FromResult(0);
        }
        /// <summary>
        /// Event for handling the response of a web request.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /// <returns></returns>
        private async Task OnResponse(object sender, SessionEventArgs e) {
            //read response headers
            var responseHeaders = e.WebSession.Response.ResponseHeaders;

            if (e.WebSession.Response.ResponseStatusCode == HttpStatusCode.OK.ToString()) {
                if (e.WebSession.Request.ContentType.Trim().ToLower().Contains("text/html")) {
                    //Get/Set response body bytes
                    byte[] responseBodyBytes = await e.GetResponseBody();
                    await e.SetResponseBody(responseBodyBytes);

                    //Get response body as string
                    string responseBody = await e.GetResponseBodyAsString();

                    //Modify e.ServerResponse
                    //Regex rex = new Regex("</body>", RegexOptions.RightToLeft | RegexOptions.IgnoreCase | RegexOptions.Multiline);
                    //string modified = rex.Replace(responseBody, "<script type =\"text/javascript\">alert('Response was modified by this script!');</script></body>", 1);

                    //Set modifed response Html Body
                    await e.SetResponseBodyString(responseBody);

                    //create packet object and send to database.
                    var domPacket = new Domain.Packet();
                    var domHeader = new Domain.Header();
                    var port = e.WebSession.IsHttps ? "443" : "80";

                    var packet = new Common.Models.Packet {
                        Destination = string.Concat(Domain.NetworkTools.DnsLookupAsync(e.WebSession.Request.RequestUri.Host), " : ", port),
                        IsIncoming = true,
                        Protocol = ProtocolType.Tcp,
                        Source = string.Concat(e.ClientEndPoint.Address, " : ", e.ClientEndPoint.Port),
                        Timestamp = DateTime.Now,
                        Url = e.WebSession.Request.Url
                    };

                    if (e.WebSession.Request.RequestHeaders.Count != 0) {
                        foreach (var header in e.WebSession.Request.RequestHeaders) {
                            packet.Headers.Add(domHeader.ConvertHeader(header));
                        }
                    }

                    domPacket.Insert(packet);
                } else {
                    // not text/html
                    //need to do something here to handle other things like images and CSS.
                    //Get/Set response body bytes
                    byte[] responseBodyBytes = await e.GetResponseBody();
                    await e.SetResponseBody(responseBodyBytes);

                    //Get response body as string
                    string responseBody = await e.GetResponseBodyAsString();

                    //Modify e.ServerResponse
                    //Regex rex = new Regex("</body>", RegexOptions.RightToLeft | RegexOptions.IgnoreCase | RegexOptions.Multiline);
                    //string modified = rex.Replace(responseBody, "<script type =\"text/javascript\">alert('Response was modified by this script!');</script></body>", 1);

                    //Set modifed response Html Body
                    await e.SetResponseBodyString(responseBody);

                    //create packet object and send to database.
                    var domPacket = new Domain.Packet();
                    var domHeader = new Domain.Header();
                    var port = e.WebSession.IsHttps ? "443" : "80";

                    var packet = new Common.Models.Packet {
                        Destination = string.Concat(Domain.NetworkTools.DnsLookupAsync(e.WebSession.Request.RequestUri.Host), " : ", port),
                        IsIncoming = true,
                        Protocol = ProtocolType.Tcp,
                        Source = string.Concat(e.ClientEndPoint.Address, " : ", e.ClientEndPoint.Port),
                        Timestamp = DateTime.Now,
                        Url = e.WebSession.Request.Url
                    };

                    if (e.WebSession.Request.RequestHeaders.Count != 0) {
                        foreach (var header in e.WebSession.Request.RequestHeaders) {
                            packet.Headers.Add(domHeader.ConvertHeader(header));
                        }
                    }

                    domPacket.Insert(packet);
                }
            } else {
                //not a 200, so deal with it
                //create packet object and send to database.
                var domPacket = new Domain.Packet();
                var domHeader = new Domain.Header();
                var port = e.WebSession.IsHttps ? "443" : "80";

                var packet = new Common.Models.Packet {
                    Destination = string.Concat(Domain.NetworkTools.DnsLookupAsync(e.WebSession.Request.RequestUri.Host), " : ", port),
                    IsIncoming = true,
                    Protocol = ProtocolType.Tcp,
                    Source = string.Concat(e.ClientEndPoint.Address, " : ", e.ClientEndPoint.Port),
                    Timestamp = DateTime.Now,
                    Url = e.WebSession.Request.Url
                };

                if (e.WebSession.Request.RequestHeaders.Count != 0) {
                    foreach (var header in e.WebSession.Request.RequestHeaders) {
                        packet.Headers.Add(domHeader.ConvertHeader(header));
                    }
                }

                domPacket.Insert(packet);
            }
        }
        /// <summary>
        /// Can do things here before the request is sent. 
        /// For instance we could filter request to certain url's or of certain types.
        /// See documentation on Titanium web proxy here
        /// https://github.com/titanium007/Titanium-Web-Proxy
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async Task OnRequest(object sender, SessionEventArgs e) {
            //read request headers
            var requestHeaders = e.WebSession.Request.RequestHeaders;

            if ((e.WebSession.Request.Method.ToUpper() == "POST"
                || e.WebSession.Request.Method.ToUpper() == "PUT")
                && e.WebSession.Request.ContentLength > 0) {
                //if (!e.IsHttps) {
                //Get/Set request body bytes
                byte[] bodyBytes = await e.GetRequestBody();
                await e.SetRequestBody(bodyBytes);

                //Get/Set request body as string
                string bodyString = await e.GetRequestBodyAsString();
                await e.SetRequestBodyString(bodyString);

                //create packet object and send to database.
                var domPacket = new Domain.Packet();
                var domHeader = new Domain.Header();
                var port = e.WebSession.IsHttps ? "443" : "80";

                var packet = new Common.Models.Packet {
                    Destination = string.Concat(Domain.NetworkTools.DnsLookupAsync(e.WebSession.Request.RequestUri.Host), " : ", port),
                    IsIncoming = false,
                    Protocol = ProtocolType.Tcp,
                    Source = string.Concat(e.ClientEndPoint.Address, " : ", e.ClientEndPoint.Port),
                    Timestamp = DateTime.Now,
                    Url = e.WebSession.Request.Url
                };

                if (e.WebSession.Request.RequestHeaders.Count != 0) {
                    foreach (var header in e.WebSession.Request.RequestHeaders) {
                        packet.Headers.Add(domHeader.ConvertHeader(header));
                    }
                }

                domPacket.Insert(packet);
                //}
            } else {
                var domPacket = new Domain.Packet();
                var domHeader = new Domain.Header();
                var port = e.WebSession.IsHttps ? "443" : "80";

                var packet = new Common.Models.Packet {
                    Destination = string.Concat(Domain.NetworkTools.DnsLookupAsync(e.WebSession.Request.RequestUri.Host), " : ", port),
                    IsIncoming = false,
                    Protocol = ProtocolType.Tcp,
                    Source = string.Concat(e.ClientEndPoint.Address, " : ", e.ClientEndPoint.Port),
                    Timestamp = DateTime.Now,
                    Url = e.WebSession.Request.Url
                };

                if (e.WebSession.Request.RequestHeaders.Count != 0) {
                    foreach (var header in e.WebSession.Request.RequestHeaders) {
                        packet.Headers.Add(domHeader.ConvertHeader(header));
                    }
                }

                domPacket.Insert(packet);
            }

            //e.Ok()
            //Task.Run(() => {
            //    var crawler = new Crawler(e.RequestUrl);
            //    crawler.Crawl();
            //    });
        }
        #region IDisposable Support
        private bool disposedValue = false; // To detect redundant calls
        protected virtual void Dispose(bool disposing) {
            if (!disposedValue) {
                if (disposing) {
                    // TODO: dispose managed state (managed objects).

                    Proxy.DisableAllSystemProxies();
                    if (IsProxyOn) {
                        Proxy.Stop();
                    }
                }

                // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
                // TODO: set large fields to null.

                disposedValue = true;
            }
        }

        // TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
        // ~Listener() {
        //   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
        //   Dispose(false);
        // }

        // This code added to correctly implement the disposable pattern.
        public void Dispose() {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
            // TODO: uncomment the following line if the finalizer is overridden above.
            // GC.SuppressFinalize(this);
        }
        #endregion
        #region RAW
        //void raw()
        //{
        //    Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.IP);
        //    s.Bind(new IPEndPoint(IPAddress.Parse("<IP Address Here of NIC to sniff>"), 0));
        //    s.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.HeaderIncluded, 1);
        //    byte[] inBytes = new byte[] { 1, 0, 0, 0 };
        //    byte[] outBytes = new byte[] { 0, 0, 0, 0 };
        //    s.IOControl(IOControlCode.ReceiveAll, inBytes, outBytes);
        //}
        #endregion
    }
}
